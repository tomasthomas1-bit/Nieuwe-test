#!/usr/bin/env python3
"""
End-to-end smoketest for the FastAPI app (staging/production).

Usage:
  python scripts/api_smoketest.py --base-url https://<your-app>.up.railway.app/

Requires:
  pip install requests
"""
from __future__ import annotations

import argparse
import sys
import time
import uuid
from datetime import datetime
from typing import Tuple, Dict, Any, List

import requests


def wait_healthz(base_url: str, timeout: int = 90):
    url = base_url.rstrip('/') + '/healthz'
    start = time.time()
    last_err = None
    while time.time() - start < timeout:
        try:
            r = requests.get(url, timeout=10)
            if r.ok and r.json().get('status') == 'ok':
                print('‚úÖ /healthz OK')
                return
        except Exception as e:
            last_err = e
        time.sleep(2)
    raise RuntimeError(f"healthz failed within {timeout}s: {last_err}")


def register(base_url: str, username: str, password: str, lat: float, lng: float) -> int:
    url = base_url.rstrip('/') + '/register'
    payload = {
        "username": username,
        "password": password,
        "name": username.capitalize(),
        "age": 30,
        "bio": "smoketest user",
        "sport_type": "run",
        "avg_distance": 10,
        "last_lat": lat,
        "last_lng": lng,
        "availability": "evenings",
    }
    r = requests.post(url, json=payload, timeout=25)
    if not r.ok:
        raise RuntimeError(f"register failed ({r.status_code}): {r.text}")
    data = r.json()
    if "user_id" not in data:
        raise RuntimeError(f"register response missing user_id: {data}")
    user_id = int(data["user_id"])
    print(f"‚úÖ registered {username} (id={user_id})")
    return user_id


def login(base_url: str, username: str, password: str) -> Tuple[requests.Session, str]:
    url = base_url.rstrip('/') + '/token'
    s = requests.Session()
    r = s.post(url, data={"username": username, "password": password}, timeout=20)
    if not r.ok:
        raise RuntimeError(f"login failed ({r.status_code}): {r.text}")
    token = r.json().get('access_token')
    if not token:
        raise RuntimeError(f"login response missing token: {r.text}")
    print(f"‚úÖ logged in {username}")
    return s, token


def auth_headers(token: str) -> Dict[str, str]:
    return {"Authorization": f"Bearer {token}"}


def get_user_with_photos(base_url: str, token: str, user_id: int) -> Dict[str, Any]:
    url = base_url.rstrip('/') + f'/users/{user_id}'
    r = requests.get(url, headers=auth_headers(token), timeout=20)
    if not r.ok:
        raise RuntimeError(f"get_user failed ({r.status_code}): {r.text}")
    return r.json()


def suggestions(base_url: str, token: str) -> List[Dict[str, Any]]:
    url = base_url.rstrip('/') + '/suggestions'
    r = requests.get(url, headers=auth_headers(token), timeout=25)
    if not r.ok:
        raise RuntimeError(f"suggestions failed ({r.status_code}): {r.text}")
    return r.json().get("suggestions", [])


def assert_in_suggestions(suggs: List[Dict[str, Any]], user_id: int, should_exist: bool, label: str):
    ids = {s["id"] for s in suggs}
    if should_exist and user_id not in ids:
        raise RuntimeError(f"{label}: expected user {user_id} IN suggestions, but not found")
    if not should_exist and user_id in ids:
        raise RuntimeError(f"{label}: expected user {user_id} NOT IN suggestions, but was present")


def block_user(base_url: str, token: str, target_id: int):
    url = base_url.rstrip('/') + '/block_user'
    r = requests.post(url, headers=auth_headers(token), params={"user_to_block_id": target_id}, timeout=20)
    if not r.ok:
        raise RuntimeError(f"block_user failed ({r.status_code}): {r.text}")
    print(f"‚úÖ blocked user {target_id}")


def swipe(base_url: str, token: str, swipee_id: int, liked: bool) -> Dict[str, Any]:
    url = base_url.rstrip('/') + f'/swipe/{swipee_id}'
    r = requests.post(url, headers=auth_headers(token), params={"liked": str(liked).lower()}, timeout=20)
    if not r.ok:
        raise RuntimeError(f"swipe failed ({r.status_code}): {r.text}")
    print(f"‚úÖ swipe -> {swipee_id} (liked={liked})")
    return r.json()


def get_matches(base_url: str, token: str) -> List[Dict[str, Any]]:
    url = base_url.rstrip('/') + '/matches'
    r = requests.get(url, headers=auth_headers(token), timeout=20)
    if not r.ok:
        print(f"‚ö†Ô∏è  get_matches returned {r.status_code}: {r.text.strip()}")
        return []
    return r.json().get("matches", [])


def send_message(base_url: str, token: str, match_id: int, message: str):
    url = base_url.rstrip('/') + '/send_message'
    r = requests.post(url, headers=auth_headers(token),
                      json={"match_id": match_id, "message": message}, timeout=20)
    if not r.ok:
        raise RuntimeError(f"send_message failed ({r.status_code}): {r.text}")
    print(f"‚úÖ message sent to {match_id}")


def get_chat(base_url: str, token: str, match_id: int) -> List[Dict[str, Any]]:
    url = base_url.rstrip('/') + f'/chat/{match_id}/messages'
    r = requests.get(url, headers=auth_headers(token), timeout=20)
    if not r.ok:
        raise RuntimeError(f"get_chat failed ({r.status_code}): {r.text}")
    msgs = r.json().get("chat_history", [])
    print(f"‚úÖ chat fetched ({len(msgs)} messages)")
    return msgs


def suggest_route(base_url: str, token: str, match_id: int):
    url = base_url.rstrip('/') + f'/suggest_route/{match_id}'
    r = requests.get(url, headers=auth_headers(token), timeout=25)
    if not r.ok:
        raise RuntimeError(f"suggest_route failed ({r.status_code}): {r.text}")
    js = r.json()
    if js.get("status") != "success" or "route_suggestion" not in js:
        raise RuntimeError(f"Unexpected suggest_route payload: {js}")
    print(f"‚úÖ route suggestion OK (to {match_id})")


def upload_photo(base_url: str, token: str, photo_url: str, is_profile_pic: bool) -> None:
    url = base_url.rstrip('/') + '/upload_photo'
    payload = {"photo_url": photo_url, "is_profile_pic": is_profile_pic}
    r = requests.post(url, headers=auth_headers(token), json=payload, timeout=20)
    if not r.ok:
        raise RuntimeError(f"upload_photo failed ({r.status_code}): {r.text}")
    print(f"‚úÖ uploaded photo (profile={is_profile_pic}) -> {photo_url}")


def delete_photo(base_url: str, token: str, photo_id: int) -> None:
    url = base_url.rstrip('/') + f'/delete_photo/{photo_id}'
    r = requests.delete(url, headers=auth_headers(token), timeout=20)
    if not r.ok:
        raise RuntimeError(f"delete_photo failed ({r.status_code}): {r.text}")
    print(f"‚úÖ deleted photo id {photo_id}")


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--base-url', required=True, help='e.g. https://web-production-ec0bc.up.railway.app/')
    args = parser.parse_args()
    base = args.base_url

    # 1) health
    wait_healthz(base)

    # Unieke suffixen
    suffix = datetime.utcnow().strftime('%Y%m%d%H%M%S') + '-' + uuid.uuid4().hex[:6]
    pw = "Sterk!Passw0rd1"

    # Users:
    # A (Antwerpen), B (Antwerpen), C (Parijs - >250km), D (Antwerpen)
    userA = f"smokeA-{suffix}"
    userB = f"smokeB-{suffix}"
    userC = f"smokeC-{suffix}"
    userD = f"smokeD-{suffix}"

    a_id = register(base, userA, pw, 51.2194, 4.4025)  # Antwerpen
    b_id = register(base, userB, pw, 51.2200, 4.4100)  # Antwerpen nabij
    c_id = register(base, userC, pw, 48.8566, 2.3522)  # Parijs
    d_id = register(base, userD, pw, 51.2250, 4.4150)  # Antwerpen nabij

    # login
    _, a_tok = login(base, userA, pw)
    _, b_tok = login(base, userB, pw)
    _, c_tok = login(base, userC, pw)
    _, d_tok = login(base, userD, pw)

    # 2) Suggestions v√≥√≥r block
    s_before = suggestions(base, a_tok)
    assert_in_suggestions(s_before, b_id, True, "suggestions-before")
    assert_in_suggestions(s_before, d_id, True, "suggestions-before")
    assert_in_suggestions(s_before, c_id, False, "suggestions-before (distance filter)")

    # 3) Block test
    block_user(base, a_tok, d_id)
    s_after_block = suggestions(base, a_tok)
    assert_in_suggestions(s_after_block, d_id, False, "suggestions-after-block")

    # 4) Match test
    swipe(base, b_tok, a_id, True)
    res = swipe(base, a_tok, b_id, True)
    if not res.get('match'):
        raise RuntimeError(f"Expected match==true after mutual like (got: {res})")

    # 5) Chat
    send_message(base, a_tok, b_id, "Hallo van smoketest!")
    msgs = get_chat(base, a_tok, b_id)
    if not any(m.get('message', '').startswith("Hallo") for m in msgs):
        raise RuntimeError("Chat message not found in history")

    # 6) Route suggestion
    suggest_route(base, a_tok, b_id)

    # 7) Foto-upload tests (let op: register voegt default profiel toe)
    #    Upload extra niet-profiel & daarna nieuwe profiel-foto
    photo1 = f"https://picsum.photos/seed/{suffix}-np/200/200"
    photo2 = f"https://picsum.photos/seed/{suffix}-pf/200/200"
    upload_photo(base, a_tok, photo1, is_profile_pic=False)
    upload_photo(base, a_tok, photo2, is_profile_pic=True)

    prof = get_user_with_photos(base, a_tok, a_id)
    photos_meta = prof.get("photos_meta", [])
    if not photos_meta or len(photos_meta) < 3:
        raise RuntimeError(f"Expected >=3 photos (default + 2 uploads); got {len(photos_meta)}")

    # Check dat precies 1 profiel-foto aanwezig is en dat dit photo2 is
    profile_photos = [p for p in photos_meta if p.get("is_profile_pic")]
    if len(profile_photos) != 1:
        raise RuntimeError(f"Expected exactly 1 profile photo; got {len(profile_photos)}")
    if profile_photos[0].get("photo_url") != photo2:
        raise RuntimeError("Newest profile photo mismatch")

    # Verwijder de niet-profiel foto (photo1)
    np = next((p for p in photos_meta if p.get("photo_url") == photo1), None)
    if not np:
        raise RuntimeError("Could not locate non-profile photo to delete")
    delete_photo(base, a_tok, np["id"])

    prof2 = get_user_with_photos(base, a_tok, a_id)
    photos_meta2 = prof2.get("photos_meta", [])
    if len(photos_meta2) != len(photos_meta) - 1:
        raise RuntimeError("Photo count did not decrease after deletion")
    profile_photos2 = [p for p in photos_meta2 if p.get("is_profile_pic")]
    if len(profile_photos2) != 1 or profile_photos2[0].get("photo_url") != photo2:
        raise RuntimeError("Profile photo state invalid after deletion")

    # 8) Match verwijderen -> negatieve chat test
    del_url = base.rstrip('/') + f'/delete/match/{b_id}'
    neg = requests.delete(del_url, headers=auth_headers(a_tok), timeout=20)
    if not neg.ok:
        raise RuntimeError(f"delete match failed ({neg.status_code}): {neg.text}")

    neg_chat = requests.post(
        base.rstrip('/') + '/send_message',
        headers=auth_headers(a_tok),
        json={"match_id": b_id, "message": "mag niet meer"},
        timeout=20
    )
    if neg_chat.status_code != 403:
        raise RuntimeError(f"Expected 403 when sending after match delete, got {neg_chat.status_code}: {neg_chat.text}")
    print("‚úÖ sending message after match delete correctly blocked (403)")

    # 9) Report test
    rep = requests.post(
        base.rstrip('/') + '/report_user',
        headers=auth_headers(a_tok),
        json={"reported_id": c_id, "reason": "smoketest"},
        timeout=20
    )
    if not rep.ok:
        raise RuntimeError(f"report_user failed ({rep.status_code}): {rep.text}")
    print(f"‚úÖ reported user {c_id}")

    print("\nüéâ ALL CHECKS PASSED")
    return 0


if __name__ == '__main__':
    try:
        sys.exit(main())
    except Exception as e:
        print(f"\n‚ùå Smoketest failed: {e}")
        sys.exit(1)
